如果你想看设计模式的理论知识，不要看这个。NO。

如果你想用设计模式来炫技，不要看这个。NO。

如果你想在你的代码里快速套用设计模式，看这个。YES。

如果你想知道什么时候使用何种模式，看这个。YES。

> 这个仓库本质上是一个代码库，用来快速套用设计模式的模板代码。这里的目的只有一个：快速使用。

# 往下看之前先需要让你知道的：
1. 仓库里一共是13种设计模式，不是所有的23种。这13个模式足够使用了。
2. 使用设计模式让代码更直观，更易懂，不是让代码变得更复杂，不要为了用而用。
3. 同上条，设计模式不要为了用而用，有时候不用代码反而更容易看懂。
4. 仓库里没有构造器模式，去看lombok插件 @builder 注解吧，可以直接使用。
5. 仓库里没有原型模式，去看MapStruct组件吧，可以直接使用。


# 设计原则
1. 找出应用中会发生变化的代码，把这变化的这部分封装起来，不要影响到不会发生变化的部分。(举例：策略模式中的鸭子的飞行行为和叫声行为，是会变化的。有可能飞，有可能不飞；有可能叫，有可能不叫。)
2. 针对接口编程，不要针对实现编程。
3. 多用组合，少用继承。
4. 尽量要让交互对象之间松耦合。
5. 开闭原则：类应该对扩展开放，对修改关闭。开放：用任何想要的行为来扩展类，关闭：不允许再修改已经成型的代码。尽量做到允许类容易被扩展，在不修改代码的前提下可搭配新的行为。
6. 依赖倒置原则：要依赖抽象，不要依赖具体类。
7. 活用空对象。当不想返回一个有意义的对象时，空对象就很有用。（举例：命令模式中的noCommand）。
8. 最少知识原则：只和你的密友谈话。（这里指的是尽量使用较少的类完成同样的任务）。但是也有缺点：采用这个原则会产生更多的包装类，有可能会导致复杂度上升。
````
   //	不采用原则
   public float getTemp() {
       Test test = station.getTest();  
       return test.getTestNew();
   }
   
   //	采用原则	直接在station中加一个getTestNew方法，减少依赖的类的数目
   public float getTemp() {
       return station.getTestNew();
   }
````
9. 钩子：是一种被声明在抽象类中的方法，只有空的或者默认的实现。钩子的存在可以让子类有能力对算法的不同点进行挂钩，由子类自行决定。（什么时候使用？在抽象父类中的部分方法是可选的时候使用。子类可以选择实现这个钩子，也可以选择不实现。）
10. 好莱坞原则：别调用我们，我们会调用你。目的是放置依赖腐败，避免高层组件和底层组件的循环依赖。底层组件可以通过钩子挂在高层组件上，但是只有高层组件才能决定什么时候调用底层组件，不允许底层组件直接调用高层组件。（举例：模板方法中，addCondiments方法的具体实现子类，可以用钩子挂在基类上，但之后基类决定是否可以调用addCondiments方法，子类不要直接调用addCondiments方法）。
11. 单一责任：一个类应该只有一个引起变化的原因。（一个类/一个方法只负责做一件事）。
12. 复合模式：在一个解决方案中同时使用多个设计模式来解决问题。
    模式说明：
1. 策略模式：对不同的行为封装成不同的计算逻辑，并且可以相互替换。（解耦，可以给不同的对象随意替换不同的行为）
2. 观察者=发布者+订阅者。观察者模式在对象之间定义一对多的依赖，当一个对象改变状态，依赖它的对象都会收到通知，并且自动更新成观察到的结果。
3. 装饰者模式：动态地将责任附加到对象上。如果要扩展功能，装饰者提供了比继承更有弹性的替代方案。（装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，达到特定的目的。对象可以在任何时候被装饰，可以运行时动态地，不限量的装饰）
4. 工厂方法模式：定义了一个创建对象的接口，但是由子类来决定要实例化哪一个类，工厂方法让类的实例化推迟到子类。
5. 抽象工厂模式：提供一个接口，用于创建相关或依赖对象的家族（一组对象，不是一个），不需要明确指定具体的类。（允许使用抽象的接口创建一组）。
6. 工厂方法使用继承，子类实现工厂方法来创建对象。抽象工厂使用组合，实现工厂接口创建对象。
7. 单例模式：确保一个类只有一个实例，并提供全局访问点。
8. 命令模式：将请求封装成对象，可以使用不同的请求、队列、或者日志请求来参数化其他对象。命令模式也支持可撤销的操作。(命令模式把方法调用封装起来变成一个一个的命令，外部调用时执行命令).
9. 适配器模式：将一个类的接口，转换成客户端希望的另一个接口。适配器让原本接口不兼容的类可以正常使用。未来如果需要改变接口，调整适配器适配的接口就可以了，客户端不用跟着修改。
10. 外观和适配器都可以包装许多类。外观的意图是简化接口，适配器的意图是将接口转换成不同的接口。
11. 外观模式：提供一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。（一个高层接口，包装子系统中多个子接口）。
12. 模板方法模式：在一个方法中定义算法的骨架，将一些具体的步骤延迟道子类中。模板方法让子类在不改变算结构的情况下，重新定义具体的某些步骤。
13. 策略模式和模板方法模式都封装算法，一个用组合，一个用继承。
14. 迭代器模式：提供一种方法可以顺序访问一个聚合对象中的各个元素（支持循环遍历不同数据类型的对象，比如数组和List），并且不暴露其内部的表示。
15. 组合模式：允许将对象组合成树形结构来表现“整体/部分”层次结构，组合让外部以一种相同的方式处理个别对象以及对象组合。
16. 迭代器+组合模式共同使用，可以循环处理树形数据结构。（像树形的菜单，树形的权限管理，树形的列表）（如果组合的树形数据过于复杂，就要考虑用缓存保存临时结果，省去遍历的开支。）
17. 状态模式：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。(封装基于状态的行为，并将行为委托到当前状态)。
18. 代理模式：为另一个对象提供一个替身或占位符，便于控制对这个对象的访问。
19. 动态代理：Java的java.lang.reflect包可以在运行时动态地创建一个代理类，实现一个或多个接口，并将方法的调用转发到所指定的类。因为实际的代理类是在运行时创建的，所以叫动态代理。（代码在开始执行时，并没有proxy类，它是根据需要在代码中传入接口以后才被创建出来的。）

# 使用场景：
1. 策略模式：随意给对象更换不同的行为。
2. 观察者模式：某个状态改变了，允许一群对象能被通知到。（比如：微服务注册中心、消费/订阅模型）。
3. 装饰模式：给主体对象添加装饰点缀，丰富主体对象的功能。
4. 工厂模式：替代new创建对象。（比如：传入不同的对象状态，创建生成操作日志）。
5. 单例模式：用双重检查机制创建生成全局唯一对象。
6. 命令模式：给下游系统发送指令，通知其处理业务问题。或者，用来撤销请求，将请求封装成命令来撤销。
7. 适配器模式：给一套业务包装起来，让调用方不改变自己代码的前提下，继续调用这个接口。不过此时这个接口内部已经由旧的业务适配成了新的业务。这套操作对调用方来说无感知。
8. 模板方法：把公共的业务抽取出来做一套模板，不一样的部分在各自的子类里实现。
9. 迭代器模式+组合模式：这两个一起使用，增删改查有层级的树形数据结构。（比如：权限、类目、菜单都属于树形结构）。
10. 外观模式：做一个高层次的接口，内部封装很多低层次的接口，操作一个高层接口，等于操作了无数低层次的接口。（比如：你家拉电闸，所有电器开关都不要挨个按了，这个电闸开关就是高层接口）。
11. 状态模式：对象的状态每发生一次改变，行为就跟着相应的变化。去看一下有限状态机吧。是状态模式更搞层级的应用。
12. 代理模式：spring源码、dubbo源码等远程调用服务的常用模式。